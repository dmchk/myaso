# Mystem is a popular morphological analyzer for Russian that is written
# in Yandex by Ilya Segalovich and Vitaly Titov. The analyzer can
# efficiently deal with non-dictionary word and produce hypotheses
# for such words. It is available on <https://tech.yandex.ru/mystem/>.
module Myaso::Mystem extend self
  # Lemma is a canonical form of the word.
  class Lemma < Struct.new(:lemma, :form, :quality, :msd, :stem_grammemes, :flex_grammemes, :flex_length, :rule_id)
    ##
    # :attr_accessor: lemma
    # A lemma of the word.

    ##
    # :attr_accessor: form
    # A normalized word form.

    ##
    # :attr_accessor: quality
    # Quality as according to +Myaso::Mystem::Library::QUALITY+.

    ##
    # :attr_accessor: msd
    # A morphosyntactic descriptor.

    ##
    # :attr_accessor: rule_id
    # An inflection rule identifier.

    # A shortcut to +Myaso::Mystem.forms+.
    def forms
      Myaso::Mystem.forms(lemma, rule_id)
    end

    # A shortcut to +Myaso::Mystem.inflect+.
    #
    # :call-seq:
    #   inflect(Hash)
    def inflect(grammemes)
      Myaso::Mystem.inflect(forms, grammemes)
    end

    def inspect #:nodoc:
      '#<%s lemma=%s msd="%s">' % [self.class.name, to_s.inspect, msd]
    end

    def to_s #:nodoc:
      lemma
    end
  end

  # A word form generated by mystem.
  class Form < Struct.new(:form, :msd, :stem_grammemes, :flex_grammemes)
    ##
    # :attr_accessor: form
    # A normalized word form.

    ##
    # :attr_accessor: msd
    # A morphosyntactic descriptor.

    def inspect #:nodoc:
      '#<%s form=%s msd="%s">' % [self.class.name, to_s.inspect, msd]
    end

    def to_s #:nodoc:
      form
    end
  end

  # Analyzes a +word+ and returns an array of lemmas, each of which
  # represent a particular ambiguous morphological interpretation.
  #
  # :call-seq:
  #   analyze(String)
  def analyze(word)
    Array.new.tap do |lemmas|
      invoke_analyze(as_symbols(word), word.length) do |lemma|
        lemma_text = MystemLemmaText(lemma)
        lemma_text_len = MystemLemmaTextLen(lemma)

        form_text = MystemLemmaForm(lemma)
        form_text_len = MystemLemmaFormLen(lemma)

        stem_grammemes = MystemLemmaStemGram(lemma).bytes
        flex_grammemes_raw = MystemLemmaFlexGram(lemma)
        flex_grammemes_len = MystemLemmaFlexGramNum(lemma)
        flex_grammemes = as_strings(flex_grammemes_raw, flex_grammemes_len)
        grammemes = stem_grammemes | flex_grammemes

        lemmas << Lemma.new(
          as_string(lemma_text, lemma_text_len),        # lemma
          as_string(form_text, form_text_len),          # form
          QUALITY[MystemLemmaQuality(lemma)],           # quality
          Myasorubka::Mystem::Binary.to_msd(grammemes), # msd
          stem_grammemes,                               # stem_grammemes
          flex_grammemes,                               # flex_grammemes
          MystemLemmaFlexLen(lemma),                    # flex_length
          MystemLemmaRuleId(lemma)                      # rule_id
        )
      end
    end
  end

  # Analyzes a +word+ and returns an array of its forms as according
  # to the given +rule_id+.
  #
  # :call-seq:
  #   forms(String, Fixnum)
  def forms(word, rule_id)
    Array.new.tap do |forms|
      invoke_analyze(as_symbols(word), word.length) do |lemma|
        next unless rule_id == MystemLemmaRuleId(lemma)

        invoke_generate(lemma) do |form|
          form_text = MystemFormText(form)
          form_text_len = MystemFormTextLen(form)

          stem_grammemes = MystemFormStemGram(form).bytes
          flex_grammemes_raw = MystemFormFlexGram(form)
          flex_grammemes_len = MystemFormFlexGramNum(form)
          flex_grammemes = as_strings(flex_grammemes_raw, flex_grammemes_len)
          grammemes = stem_grammemes | flex_grammemes

          forms << Form.new(
            as_string(form_text, form_text_len),          # form
            Myasorubka::Mystem::Binary.to_msd(grammemes), # msd
            stem_grammemes,                               # stem_grammemes
            flex_grammemes,                               # flex_grammemes
          )
        end
      end
    end
  end

  # Finds exact matches of +grammemes+ for the provided +forms+ of a word.
  # It is necessary to be careful because computational linguistics is a
  # hard field.
  #
  # :call-seq:
  #   inflect([Form], Hash)
  def inflect(forms, grammemes)
    forms.select do |form|
      grammemes.inject(true) { |r, (k, v)| r && form.msd.grammemes[k] == v }
    end
  end

  protected

  def invoke_analyze(symbols, length, &block) #:nodoc:
    analyzes = MystemAnalyze(symbols, length)
    MystemAnalysesCount(analyzes).times do |i|
      block.call(MystemLemma(analyzes, i))
    end
  ensure
    MystemDeleteAnalyses(analyzes)
  end

  def invoke_generate(lemma, &block) #:nodoc:
    forms = MystemGenerate(lemma)
    MystemFormsCount(forms).times do |i|
      block.call(MystemForm(forms, i))
    end
  ensure
    MystemDeleteForms(forms)
  end

  def as_symbols(string) #:nodoc:
    FFI::MemoryPointer.
      new(:ushort, string.length).
      write_array_of_short(string.chars.map!(&:ord))
  end

  def as_string(symbols, length) #:nodoc:
    symbols.read_array_of_ushort(length).
      map! { |c| c.chr(Encoding::UTF_8) }.
      join
  end

  def as_strings(grammemes, grammemes_length) #:nodoc:
    Array.new.tap do |bytes|
      grammemes.get_array_of_string(0, grammemes_length).each do |ids|
        bytes << ids.bytes
      end
      bytes.flatten!
      bytes.uniq!
    end
  end
end
